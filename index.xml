<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Efficient web app architecture on Efficient-web-app-architecture</title><link>https://dwtechs.github.io/efficient-web-app-architecture/</link><description>Recent content in Efficient web app architecture on Efficient-web-app-architecture</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dwtechs.github.io/efficient-web-app-architecture/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://dwtechs.github.io/efficient-web-app-architecture/REST/versioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/REST/versioning/</guid><description>It is important to make sure you don&amp;rsquo;t break the system for current consumers when you update your APIs. They need to be able to use it as usual while new consumers will use the new features. For this you need to version yout API. There are several ways to do so.
URI versioning Each time you modify the web API or change the schema of resources, you add a version number to the URI for each resource.</description></item><item><title>API</title><link>https://dwtechs.github.io/efficient-web-app-architecture/REST/api/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/REST/api/</guid><description>Overview A REST API (also known as RESTful API) is an Application Programming Interface that conforms to the constraints of REST architectural style and allows for interaction with RESTful web services. REST stands for REpresentational State Transfer and was created by Roy Fielding in 2000 who also co-founded the Apache HTTP Server project and has been heavily involved in the development of HTML.
What is an API An API helps you communicate with a system so it can understand and fulfill the request.</description></item><item><title>Challenges</title><link>https://dwtechs.github.io/efficient-web-app-architecture/microservices/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/microservices/overview/</guid><description>If your client is thinking about shifting to a microservices architecture, he also needs to change the way people work, not just the apps. Organizational and cultural changes are identified as challenges in part because each team will have its own deployment cadence and will be responsible for a unique service with its own set of customers. Those may not be typical developer concerns, but they will be essential to a successful microservices architecture.</description></item><item><title>Conclusion</title><link>https://dwtechs.github.io/efficient-web-app-architecture/microservices/mono-repo-vs-multi-repo/conclusion/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/microservices/mono-repo-vs-multi-repo/conclusion/</guid><description>How to choose? Different companies and projects will benefit from one strategy or the other based on their unique conditions. Here is a list of criterias you can use to help you choose :
Are different programming languages involved? Do they require a particular software installed or special hardware to run? How many deployment tools are required, and how complex are they to set up? What is the culture in the company?</description></item><item><title>Design</title><link>https://dwtechs.github.io/efficient-web-app-architecture/REST/design/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/REST/design/</guid><description>Overview A well-designed web API should aim to support two key principles:
Platform independence. Any client should be able to call the API, regardless of how the API is implemented internally. This requires using standard protocols, and having a mechanism whereby the client and the web service can agree on the format of the data to exchange.
Service evolution. The web API should be able to evolve and add functionality independently from client applications.</description></item><item><title>Operations</title><link>https://dwtechs.github.io/efficient-web-app-architecture/REST/operations/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/REST/operations/</guid><description>Define operations in terms of HTTP methods The HTTP protocol defines a number of methods that assign semantic meaning to a request. The common HTTP methods used by most RESTful web APIs are:
GET retrieves a representation of the resource at the specified URI. The body of the response message contains the details of the requested resource. POST creates a new resource at the specified URI. The body of the request message provides the details of the new resource.</description></item><item><title>Organization</title><link>https://dwtechs.github.io/efficient-web-app-architecture/microservices/organization/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/microservices/organization/</guid><description>Managing microservices in a mono-repo strategy Microservices architecture implies thorough reflection on the way of working and organization of the teams. With Docker-compose and Gitlab CI we optimize processes and ensure Microservices architecture and mono-repo strategy are used at their full potential by fully facilitate workflows and team work.
Those tools helps the teams deliver efficiently and undertake inherent challenges of this architecture :
Integration: Manage relations between all microservices &amp;ldquo;natively&amp;rdquo; within one repository Versioning: Secure the global version and history with proper package management Environment setup: Pull and launch the application in few minutes with Docker-compose CI/CD: Test and deploy the application autmaticaly with low maintenance cost with Docker and Gitlab CI.</description></item><item><title>Overview</title><link>https://dwtechs.github.io/efficient-web-app-architecture/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/intro/</guid><description>Web application architecture is a blueprint of simultaneous interactions between components, databases, middleware systems, user interfaces, and servers in an application. It can also be described as the layout that logically defines the connection between the server and client-side for a better web experience.
Market trends keep changing, user expectations keep evolving, and the growth of a business is never-ending. A web app needs an architecture to lay a strong foundation, and without it, your business app will be diving in the big ball of mud architecture anti-pattern.</description></item><item><title>SQL or NoSQL</title><link>https://dwtechs.github.io/efficient-web-app-architecture/sqlnosql/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/sqlnosql/</guid><description>When developing a microservice API, in most cases you will need to store data in a database. The great thing about microservice architecture is that you have one database per microservice, meaning you can pick the best system for each one of them.
Differences between SQL &amp;amp; NoSQL SQL databases are relational, NoSQL databases are non-relational. SQL databases use structured query language and have a predefined schema. NoSQL databases have dynamic schemas for unstructured data.</description></item><item><title>What is Mono-repository</title><link>https://dwtechs.github.io/efficient-web-app-architecture/microservices/mono-repo-vs-multi-repo/mono-repo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/microservices/mono-repo-vs-multi-repo/mono-repo/</guid><description>The mono-repo approach uses a single repository to host all the code for the multiple services composing a micro-services. At its most extreme, the whole codebase from a company — spanning various projects and coded in different languages — can be hosted in a single repository but here we will only talk about one micro-services application.
Advantages of Mono-repo A single place to store all the project code. Can be accessed by everyone in the team Easy to reuse and share code, collaborate with teams Easy to understand the impact of your change on the entire project.</description></item><item><title>What is multi-repository</title><link>https://dwtechs.github.io/efficient-web-app-architecture/microservices/mono-repo-vs-multi-repo/multi-repo/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/microservices/mono-repo-vs-multi-repo/multi-repo/</guid><description>The multi-repo approach uses several repositories to host the multiple libraries or services of a project. At its most extreme, it will host every minimum set of reusable code or standalone functionality (such as a microservice) under its own repository.
Advantages of Multi-repo Each service and library have its own versioning Code check-outs and pulls are small and separate, thus there are no performance issues even if the project size grows Teams can work independently and do not need access to the entire codebase Faster development and flexibility Each service can be released separately and have its own deployment cycle Better access control – all teams do not need to have full access to all the libraries – but can get read access if they need Independent library versioning When tagging a repository, its whole codebase is assigned the “new” tag.</description></item><item><title>What is the MVC pattern</title><link>https://dwtechs.github.io/efficient-web-app-architecture/mvc/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-web-app-architecture/mvc/</guid><description>MVC is a paradigm concerned with how object oriented systems could have UIs. It helps break up the code into separate components. This way, it is much easier to manage and make changes to either side without them interfering with each other.
It is a simple concept. The code is divided into three components :
Model for data processing and business logic View for the graphical user interface representing the model state Controller for the link between View and models.</description></item></channel></rss>